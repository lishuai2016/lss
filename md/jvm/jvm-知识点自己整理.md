
<!-- TOC -->

- [01、新生代对象进入老年代的条件](#01新生代对象进入老年代的条件)
- [02、年轻代GC的触发条件](#02年轻代gc的触发条件)
- [03、老年代GC的触发条件](#03老年代gc的触发条件)
- [04、jvm调优的原则](#04jvm调优的原则)
- [05、一个普通java类执行过程](#05一个普通java类执行过程)
- [06、类加载和初始化](#06类加载和初始化)
- [07、类加载器](#07类加载器)
- [08、通过一段代码了解内存区域的划分](#08通过一段代码了解内存区域的划分)
- [09、什么情况下方法区里的类会被回收？](#09什么情况下方法区里的类会被回收)
- [10、为什么内存区域要分块？jvm分代模型存在的意义？](#10为什么内存区域要分块jvm分代模型存在的意义)
- [11、jvm核心参数说明](#11jvm核心参数说明)
- [12、如何识别哪些是垃圾对象？要回收哪些对象？](#12如何识别哪些是垃圾对象要回收哪些对象)
- [13、垃圾回收算法和垃圾收集器](#13垃圾回收算法和垃圾收集器)
    - [0、垃圾回收算法](#0垃圾回收算法)
        - [1、复制算法[用于新生代或者G1]](#1复制算法用于新生代或者g1)
        - [2、标记清除算法](#2标记清除算法)
        - [3、标记整理算法](#3标记整理算法)
        - [4、分代回收算法](#4分代回收算法)
    - [1、Serial和Serial Old垃圾回收器：分别用来回收新生代和老年代的垃圾对象](#1serial和serial-old垃圾回收器分别用来回收新生代和老年代的垃圾对象)
    - [2、ParNew垃圾回收器：新生代多线程垃圾回收器](#2parnew垃圾回收器新生代多线程垃圾回收器)
    - [3、CMS（Concurrent Mark Sweep）垃圾回收器：标记-清除算法](#3cmsconcurrent-mark-sweep垃圾回收器标记-清除算法)
    - [4、G1垃圾回收器](#4g1垃圾回收器)
        - [1、G1的设计思想](#1g1的设计思想)
        - [2、G1内存模型以及使用的垃圾回收算法](#2g1内存模型以及使用的垃圾回收算法)
        - [3、如何设定G1有多少个Region呢？每个Region的大小是多大呢？](#3如何设定g1有多少个region呢每个region的大小是多大呢)
        - [4、G1新生代大小设置](#4g1新生代大小设置)
        - [5、G1的新生代垃圾回收](#5g1的新生代垃圾回收)
        - [6、G1新生代对象什么时候进入老年代？](#6g1新生代对象什么时候进入老年代)
        - [7、G1针对大对象的处理](#7g1针对大对象的处理)
        - [8、什么时候触发新生代+老年代的混合垃圾回收？](#8什么时候触发新生代老年代的混合垃圾回收)
        - [9、G1垃圾回收的过程](#9g1垃圾回收的过程)
- [98、Java线程和操作系统线程的关系](#98java线程和操作系统线程的关系)

<!-- /TOC -->

# 01、新生代对象进入老年代的条件

- 1、对象年龄太大了，这种对象一般很少，都是系统中确实需要长期存在的核心组件，他们一般不需要被回收掉，所以在新生代熬过默认15次垃圾回收之后就会进入老年代。

- 2、动态年龄判定规则，如果一次新生代gc过后，发现Survivor区域中的几个年龄的对象加起来超过了Survivor区域的50%，比如说年龄1+年龄2+年龄3的对象大小总和，超过了Survivor区域的50%，此时就会把年龄3以上的对象都放入老年代。

- 3、新生代垃圾回收过后，存活对象太多了，无法放入 Surviovr中，此时直接进入老年代。

- 4、大对象直接进入老年代 G1例外 有专门存储大对象的region(H) ；

其实上述条件中，第二个和第三个都是很关键的，通常如果你的新生代中的Survivor区域内存过小，就会导致上述第二个和第三个条件频繁发生，然后导致大量对象快速进入老年代，进而频繁触发老年代的gc


# 02、年轻代GC的触发条件

Young GC其实一般就是在新生代的`Eden区域满了`之后就会触发，采用复制算法来回收新生代的垃圾


# 03、老年代GC的触发条件

- （1）发生Young GC之前进行检查，如果“老年代可用的连续内存空间” < “新生代历次Young GC后升入老年代的对象总和的平均大小”，说明本次Young GC后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间。此时必须先触发一次Old GC给老年代腾出更多的空间，然后再执行Young GC。[-XX:-HandlePromotionFailure，1.6之后废弃]

- （2）执行Young GC之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次Old GC。

- （3）老年代内存使用率超过了92%，也要直接触发Old GC，当然这个比例是可以通过参数调整的。

其实说白了，上述三个条件你概括成一句话，就是老年代空间也不够了，没法放入更多对象了，这个时候务必执行Old GC对老年代进行垃圾回收。

# 04、jvm调优的原则

**尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。**

jvm的优化就在于尽量降低老年代gc，也就是尽量不然对象进入老年代，而最根本的就是对于新生代的内存分配（E区和S区分配），同时如果是大内存的场景对于垃圾回收器就可以考虑G1.平衡垃圾回收的资源数和时间关系。



# 05、一个普通java类执行过程

编写的xxx.java执行的流程。首先编写的是xxx.java文件，然后经过编译后生成xxx.class文件，封装成x.jar包，当我们执行名称java -jar x.jar，会启动一个jvm，这个jvm进程会把这个jar包的主类的main函数执行，在执行main函数之前需要先由类加载器加载main函数所在的主类，然后在main函数执行的过程中，使用到那个类，然后由类加载器去加载这个类。

![05_执行代码](../../pic/2019-08-03-18-21-13.png)

备注：使用java -jar x.jar执行的时候，需要保证在打这个jar包的时候指定主类的main函数入口。


# 06、类加载和初始化

类的加载时机是在使用的时候才会进行加载。类的加载和初始化过程：加载 -> 验证 -> 准备[分配内存设置默认值] -> 解析 -> 初始化[静态变量和静态代码块] -> 使用 -> 卸载。重要的是准备和初始化阶段，准备阶段为类的静态变量等属性分配内存空间，初始化阶段给静态属性进行初始化赋值。[这里的初始化为类的初始化而不是实例的初始化]。

> 类的加载和初始化时机[类加载了为什么会存在不进行初始化???]

- 类加载：使用的时候才会加载

- 类的初始化

我把一直理解类的 加载->验证->准备->解析->初始化是一个连续的动作，以为类一旦加载必定会立即初始化。

补充类初始化的时机如下：

- 1.当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）

- 2.当调用某个类的静态方法时

- 3.当使用某个类或接口的静态字段时

- 4.调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时

- 5.当初始化某个子类时

- 6.当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类） 所以System.ou.println(Test.class)
 
不满足上面6种情况，也就没有做初始化

# 07、类加载器

双亲委派机制：

就是假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载。但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。

![](../../pic/2019-08-03-22-27-18.png)

第一个方向的委托加载：应用类加载器--->扩展类加载器--->启动类加载器

第二个方向的当前类加载器加载不到，下放加载:启动类加载器--->扩展类加载器--->应用类加载器


# 08、通过一段代码了解内存区域的划分

内存的区域包含哪些：

- 程序计数器，保存当前线程执行到那条字节码了；

- 虚拟机栈[每个线程都会存在对应的虚拟机栈]，当前线程执行的方法中包含的信息，每个方法是一个栈帧，栈帧中存的是局部变量和方法相关的信息；

- 本地方法栈，保存当前线程的native方法相关信息，同虚拟机栈；

- 方法区/元数据区：保存的类的相关信息

- 堆：保存对象


![](../../pic/2019-08-03-23-27-44.png)

![](../../pic/2019-08-03-23-30-22.png)

> 为什么需要垃圾回收？

在程序的运行过程中，我们在方法中会创建对象并赋值给方法内的局部变量，当方法执行完毕，从虚拟机栈出栈，局部变量被销毁，就会造成创建的对象没有再被应用，成为垃圾对象，如果不进行销毁就会占着内存不释放，长时间下去就会造成内存不足，因此需要进行垃圾回收，垃圾回收是一个后台线程进行的，把多余的垃圾对象清理掉。


# 09、什么情况下方法区里的类会被回收？

- 1、首先该类的所有实例对象都已经从Java堆内存里被回收

- 2、其次加载这个类的ClassLoader已经被回收

- 3、最后，对该类的Class对象没有任何引用

满足上面三个条件就可以回收该类了。


# 10、为什么内存区域要分块？jvm分代模型存在的意义？

jvm分代模型的原因是不同的代使用不同的垃圾回收算法，本质是不同的`对象生存周期不一样`，大部分对象生成以后很快就不再使用成为垃圾对象，只有少数的对象才会长时间存活，被程序不停的使用。

为什么老年代不采用复制算法，像新生代那样一个E两个S呢，或者说为什么新生代不采用标记整理算法呢？

老年代存活对象太多了，如果采用复制算法，每次都挪动可能90%的存活对象，这就不合适了。所以采用先把存活对象挪动到一起紧凑一些，然后回收垃圾对象的方式。


# 11、jvm核心参数说明

-Xms：Java堆内存的初始大小

-Xmx：Java堆内存的最大大小

-Xmn：Java堆内存中的新生代大小，扣除新生代剩下的就是老年代的内存大小了

-XX:PermSize：永久代大小

-XX:MaxPermSize：永久代最大大小

-Xss：每个线程的栈内存大小

-XX:MetaspaceSize： 1.8的元数据初始大小

-XX:MaxMetaspaceSize： 1.8的元数据初始最大大小

一般情况-Xms=-Xmx、-XX:PermSize=-XX:MaxPermSize、-XX:MetaspaceSize=-XX:MaxMetaspaceSize。


![](../../pic/2019-08-04-10-10-30.png)


-XX:MaxTenuringThreshold：多少岁进入老年代，默认是15岁

-XX:PretenureSizeThreshold：大对象直接分配到老年代的门限


-XX:+UseParNewGC:指定新生代进行垃圾回收器为ParNew,默认给自己设置的垃圾回收线程的数量就是跟CPU的核数是一样的，一般不需要手动设置线程数。

-XX:ParallelGCThreads：强制设置ParNew并发垃圾回收线程数

-XX:+UseConcMarkSweepGC：年代使用CMS垃圾回收器

-XX:CMSInitiatingOccupancyFaction：参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是92%。原因是需要在并发清理阶段，应用有可能创建的对象进入老年代，需要预留一部分内存给这些“浮动垃圾”，这些垃圾本次GC不会被回收，只能等到下次GC的时候被回收。

-XX:+UseCMSCompactAtFullCollection：默认就打开，意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片

-XX:CMSFullGCsBeforeCompaction：意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是0，意思就是每次Full GC之后都会进行一次内存整理

-XX:+UseG1GC:使用G1垃圾回收器，JVM最多可以有2048个Region，每个Region大小=我们设置的堆大小/2048，比如4G的内存，每个Region2M。并且每个Region大小为2的倍数。一般不需要指定每个Region的大小。

-XX:G1HeapRegionSize：强制指定Region大小。

-XX:G1NewSizePercent：设置新生代初始占比的，其实维持默认值5%即可，因为在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过默认60%，可以通过参数设置最大占比-XX:G1MaxNewSizePercent。而且一旦Region进行了垃圾回收，此时新生代的Region数量还会减少，这些其实都是动态的。

-XX:G1MaxNewSizePercent：设置新生代的最大占比

-XX:MaxGCPauseMills：G1执行GC的时候最多可以让系统停顿多长时间，默认值是200ms。

-XX:InitiatingHeapOccupancyPercent:如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。

-XX:G1MixedGCCountTarget:就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次.

-XX:G1HeapWastePercent:默认5%，空闲出多少Region占总数比例停止混合回收过程。

-XX:G1MixedGCLiveThresholdPercent：他的默认值是85%，意思就是确定要回收的Region的时候，必须是存活对象低于85%的Region才可以进行回收。否则要是一个Region的存活对象多余85%，你还回收他干什么？这个时候要把85%的对象都拷贝到别的Region，这个成本是很高的。



# 12、如何识别哪些是垃圾对象？要回收哪些对象？

1、GC roots对象

一句话总结：只要你的对象被方法的局部变量、类的静态变量给引用了，就不会回收他们。


2、java对象的几种引用

- 强引用：代表绝对不能回收的对象；

- 软引用：SoftReference包裹的对象，正常情况下垃圾回收是不会回收软引用对象的，但是如果你进行垃圾回收之后，发现内存空间还是不够存放新的对象，内存都快溢出了此时就会把这些软引用对象给回收掉，哪怕他被变量引用了，但是因为他是软引用，所以还是要回收。

- 弱引用：WeakReference包裹的对象,你这个弱引用就跟没引用是类似的，如果发生垃圾回收，就会把这个对象回收掉;

- 虚引用：使用的情况比较少；

有GC Roots引用的对象不能回收，没有GC Roots引用的对象可以回收，如果有GC Roots引用，但是如果是软引用或者弱引用的，也有可能被回收掉。

3、finalize()

在对象回收的时候会调用对象finalize()这个函数，这个时候，对象有一次拯救自己的时候，不常用。


# 13、垃圾回收算法和垃圾收集器


分代垃圾回收模型、垃圾回收线程、垃圾回收器、以及垃圾回收算法之间的关系：

![](../../pic/2020-03-14-09-32-11.png)


## 0、垃圾回收算法

### 1、复制算法[用于新生代或者G1]

复制算法，然后把内存区域划分为3个部分，E区和2个S区，E：S=8:1，[开始的时候E,S区都是空着的]新创建的对象一般先放在E区，当E区满的时候，触发monitor GC，标记E区中的存活对象，然后把标记的存活对象移动到一个S区，然后清空E区，此后新创建的对象不停的放在E区，当E区又满的时候，会再次触发垃圾回收，此时标记的是E区和那个存放对象的S区的对象，把存活的对象放到另外一个S区，然后清空E区和S区，之后重复这个流程。

新生代中分为一个 `Eden` 区和两个 `Survivor` 区。通常两个区域的比例是 `8:1:1` ，使用时会用到 `Eden` 区和其中一个 `Survivor` 区。当发生回收时则会将还存活的对象从 `Eden` ，`Survivor` 区拷贝到另一个 `Survivor` 区，当该区域内存也不足时则会使用分配担保利用老年代来存放内存。

### 2、标记清除算法

标记清除算法分为两个步骤，标记和清除。首先将**不需要回收的对象**标记起来，然后再清除其余可回收对象。但是存在两个主要的问题:
- 标记和清除的效率都不高。
- 清除之后容易出现不连续内存，当需要分配一个较大内存时就不得不需要进行一次垃圾回收。


### 3、标记整理算法

复制算法如果在`存活对象较多时效率明显会降低`，特别是在老年代中并没有多余的内存区域可以提供内存担保。

所以老年代中使用的时候`标记整理算法`，它的原理和`标记清除算法`类似，只是最后一步的清除改为了将存活对象全部移动到一端，然后再将边界之外的内存全部回收。


### 4、分代回收算法

现代多数的商用 `JVM` 的垃圾收集器都是采用的分代回收算法，和之前所提到的算法并没有新的内容。

只是将 Java 堆分为了新生代和老年代。由于新生代中存活对象较少，所以采用**复制算法**，简单高效。

而老年代中对象较多，并且没有可以担保的内存区域，所以一般采用**标记清除或者是标记整理算法**。














> 垃圾收集器组合

![](../../pic/gc.jpg)


## 1、Serial和Serial Old垃圾回收器：分别用来回收新生代和老年代的垃圾对象

工作原理就是单线程运行，垃圾回收的时候会停止我们自己写的系统的其他工作线程，让我们系统直接卡死不动，然后让他们垃圾回收，这个现在一般写后台Java系统几乎不用。

## 2、ParNew垃圾回收器：新生代多线程垃圾回收器

![](../../pic/2020-03-14-09-39-07.png)

相当于上面Serial垃圾回收器的多线程版本。

ParNew和CMS垃圾回收器：ParNew现在一般都是用在新生代的垃圾回收器，CMS是用在老年代的垃圾回收器，他们都是多线程并发的机制，性能更好，现在一般是线上生产系统的标配组合。

## 3、CMS（Concurrent Mark Sweep）垃圾回收器：标记-清除算法

CMS[标记清除算法+整理碎片？]在执行一次垃圾回收的过程一共分为4个阶段：

- 1、初始标记：标记那些GC root对象；

- 2、并发标记：找老年代的对象那些被GC root对象直接或者间接引用了；

- 3、重新标记：处理在并发标记阶段产生的对象；

- 4、并发清理：清理垃圾对象；

备注：1和3阶段需要stop the world，但是很快；2和4过程比较耗时，但是可以可工作线程并发进行。

在并发标记和并发清理阶段垃圾线程数会消耗CPU资源，影响应用的运行。CMS默认启动的垃圾回收线程的数量是（CPU核数 + 3）/ 4。

CMS这个并发垃圾回收的机制存在的问题：

- 1、会消耗CPU资源:启用的垃圾回收线程消耗的。

- 2、Concurrent Mode Failure问题：CMS垃圾回收期间，系统程序要放入老年代的对象大于了可用内存空间，会发生Concurrent Mode Failure。此时就会自动用“Serial Old”垃圾回收器替代CMS，就是直接强行把系统程序“Stop the World”，重新进行长时间的GC Roots追踪，标记出来全部垃圾对象，不允许新的对象产生。然后一次性把垃圾对象都回收掉，完事儿了再恢复系统线程。可以通过设置这个参数来避免，预留一部分空间。“-XX:CMSInitiatingOccupancyFaction”参数可以用来设置老年代占用多少比例的时候触发CMS垃圾回收，JDK 1.6里面默认的值是92%。

- 3、内存碎片问题：老年代的CMS采用“标记-清理”算法，每次都是标记出来垃圾对象，然后一次性回收掉，这样会导致大量的内存碎片产生。CMS有一个参数是“-XX:+UseCMSCompactAtFullCollection”，默认就打开了，他意思是在Full GC之后要再次进行“Stop the World”，停止工作线程，然后进行碎片整理，就是把存活对象挪到一起，空出来大片连续内存空间，避免内存碎片。还有一个参数是“-XX:CMSFullGCsBeforeCompaction”，这个意思是执行多少次Full GC之后再执行一次内存碎片整理的工作，默认是0，意思就是每次Full GC之后都会进行一次内存整理。

> 一般参数设置：

“-Xms3072M -Xmx3072M -Xmn2048M -Xss1M  -XX:PermSize=256M -XX:MaxPermSize=256M  -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC”


## 4、G1垃圾回收器


G1垃圾收集器重要调优参数,大致按重要性排序
```
-XX:+UseG1GC
-Xmx< nG >
-Xms< nG >
-XX:MaxGCPauseMillis=< ms >
-XX:InitiatingHeapOccupancyPercent=< % >
-XX:+PrintGCDetails
-XX:+PrintAdaptiveSizePolicy
-XX:G1HeapRegionSize
-XX:+PrintReferenceGC
-XX:+ParallelRefProcEnabled
-XX:ParallelGCThreads=n
-XX:ConcGCThreads=n
-XX:G1MixedGCCountTarget=n
```


### 1、G1的设计思想

ParNew + CMS带给我们的痛点是什么？Stop the World。

无论是新生代垃圾回收，还是老年代垃圾回收，都会或多或少产生“Stop the World”现象，对系统的运行是有一定影响的。所以其实之后对垃圾回收器的优化，都是朝着减少“Stop the World”的目标去做的。在这个基础之上，G1垃圾回收器就应运而生了，他可以提供比“ParNew + CMS”组合更好的垃圾回收的性能。


G1对应的是一大堆的Region内存区域，每个Region的大小是一致的.

![](../../pic/2020-03-14-11-12-24.png)

设计思路：G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小Region，以及追踪每个Region中可以回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时间内尽量回收尽可能多的垃圾对象。

其实在G1对应的内存模型中，Region随时会属于新生代也会属于老年代，所以没有所谓新生代给多少内存，老年代给多少内存这 一说了.实际上新生代和老年代各自的内存区域是不停的变动的，由G1自动控制。

触发垃圾回收的时候，可以根据设定的预期系统停顿时间，来选择最少回收时间和最多回收对象的Region进行垃圾回收，保证GC对系统停顿的影响在可控范围内，同时还能尽可能回收最多的对象。



### 2、G1内存模型以及使用的垃圾回收算法


G1整体[新生代垃圾回收+]是基于复制算法进行Region垃圾回收的，不会出现内存碎片的问题，不需要像CMS那样标记-清理之后，再进行内存碎片的整理。

而且G1中Region依旧会划分新生代和老年代，并且新生代中还有Eden和Survivor，他们会各自占据不同的Region。

![](../../pic/2020-03-14-11-08-44.png)

![](../../pic/2020-03-14-11-23-53.png)


### 3、如何设定G1有多少个Region呢？每个Region的大小是多大呢？

其实这个默认情况下自动计算和设置的，我们可以给整个堆内存设置一个大小，比如说用“-Xms”和“-Xmx”来设置堆内存的大小。然后JVM启动的时候一旦发现你使用的是G1垃圾回收器，可以使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，此时会自动用堆大小除以2048。因为JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的。

比如说堆大小是4G，那么就是4096MB，此时除以2048个Region，每个Region的大小就是2MB。大概就是这样子来决定Region的数量和大小的，大家一般保持默认的计算方式就可以。
如果通过手动方式来指定，则是“-XX:G1HeapRegionSize”

### 4、G1新生代大小设置

刚开始的时候，默认新生代对堆内存的占比是`5%`，也就是占据200MB左右的内存，对应大概是100个Region，这个是可以通过“-XX:G1NewSizePercent”来设置新生代初始占比的，其实维持这个默认值即可。

因为在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“-XX:G1MaxNewSizePercent”。而且一旦Region进行了垃圾回收，此时新生代的Region数量还会减少，这些其实都是动态的。

### 5、G1的新生代垃圾回收

新生代的垃圾回收还是采用了复制算法，只不过会考虑预设GC停顿时间，保证垃圾回收的停顿时间不能超过预设时间，因此会挑选一些Region来进行垃圾回收。

既然G1的新生代也有Eden和Survivor的区分，那么触发垃圾回收的机制都是类似的。

随着不停的在新生代的Eden对应的Region中放对象，JVM就会不停的给新生代加入更多的Region，直到新生代占据堆大小的最大比例60%。这个时候还是会触发新生代的GC，G1就会用之前说过的复制算法来进行垃圾回收，进入一个“Stop the World”状态。然后把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象。

但是这个过程跟之前是有区别的，因为G1是可以设定目标GC停顿时间的，也就是G1执行GC的时候最多可以让系统停顿多长时间，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。那么G1就会通过之前说的，对每个Region追踪回收他需要多少时间，可以回收多少对象来选择回收一部分的Region，保证GC停顿时间控制在指定范围内，尽可能多的回收掉一些对象。

### 6、G1新生代对象什么时候进入老年代？

在G1的内存模型下，新生代和老年代各自都会占据一定的Region，老年代也会有自己的Region。按照默认新生代最多只能占据堆内存60%的Region来推算，老年代最多可以占据40%的Region。

（1）对象在新生代躲过了很多次的垃圾回收，达到了一定的年龄了，“-XX:MaxTenuringThreshold”参数可以设置这个年龄，他就会进入老年代

（2）动态年龄判定规则，如果一旦发现某次新生代GC过后，存活对象超过了Survivor的50%。此时就会判断一下，比如年龄为1岁，2岁，3岁，4岁的对象的大小总和超过了Survivor的50%，此时4岁以上的对象全部会进入老年代，这就是动态年龄判定规则。

（3）年轻代GC过后survivor区放不下存活对象。

注意：`和ParNew相比少了大对象直接放到老年代，因为G1针对大对象放了专门的region存储大对象`


### 7、G1针对大对象的处理

G1提供了专门的Region来存放大对象，而不是让大对象进入老年代的Region中。在G1中，大对象的判定规则就是一个大对象超过了一个Region大小的50%，比如按照上面算的，每个Region是2MB，只要一个大对象超过了1MB，就会被放入大对象专门的Region中。而且一个大对象如果太大，可能会横跨多个Region来存放。

![](../../pic/2020-03-14-11-31-34.png)


大对象既然不属于新生代和老年代，那么什么时候会触发垃圾回收呢？

也很简单，其实新生代、老年代在回收的时候，会顺带带着大对象Region一起回收，所以这就是在G1内存模型下对大对象的分配和回收的策略。

### 8、什么时候触发新生代+老年代的混合垃圾回收？

G1有一个参数，是“-XX:InitiatingHeapOccupancyPercent”，他的默认值是45%。意思就是说，如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段（Mixed GC）。


### 9、G1垃圾回收的过程

- 1、首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC  Roots直接能引用的对象，这个过程速度是很快的。

- 2、接着会进入“并发标记”的阶段，这个阶段会允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象。

- 3、最终标记阶段，这个阶段会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记阶段记录的那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象

- 4、最后一个阶段，就是“混合回收“阶段[Mixed GC]，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回收的预期性能和效率。接着会停止系统程序，然后全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为必须让垃圾回收的停顿时间控制在我们指定的范围内。


而且大家需要在这里有一点认识，其实老年代对堆内存占比达到45%的时候，触发的是“混合回收”。也就是说，此时垃圾回收不仅仅是回收老年代，还会回收新生代，还会回收大对象。


那么，到底是回收这些区域的哪些Region呢？

那就要看情况了，因为我们设定了对GC停顿时间的目标，所以说他会从新生代、老年代、大对象里各自挑选一些Region，保证用指定的时间（比如200ms）回收尽可能多的垃圾，这就是所谓的混合回收。

但是最后一个阶段混合回收的时候，其实会停止所有程序运行，所以说G1是允许执行多次混合回收。

比如先停止工作，执行一次混合回收回收掉 一些Region，接着恢复系统运行，然后再次停止系统运行，再执行一次混合回收回收掉一些Region。

有一些参数可以控制这个，比如“-XX:G1MixedGCCountTarget”参数，就是在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次.

意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。

那么为什么要反复回收多次呢？

因为你停止系统一会儿，回收掉一些Region，再让系统运行一会儿，然后再次停止系统一会儿，再次回收掉一些Region，这样可以尽可能让系统不要停顿时间过长，可以在多次回收的间隙，也运行一下。

还有一个参数，就是“-XX:G1HeapWastePercent”，默认值是5%.他的意思就是说，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他Region，然后这个Region中的垃圾对象全部清理掉.这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收，意味着本次混合回收就结束了。

而且从这里也能看出来G1整体是基于复制算法进行Region垃圾回收的，不会出现内存碎片的问题，不需要像CMS那样标记-清理之后，再进行内存碎片的整理。


还有一个参数，“-XX:G1MixedGCLiveThresholdPercent”，他的默认值是85%，意思就是确定要回收的Region的时候，必须是存活对象低于85%的Region才可以进行回收.否则要是一个Region的存活对象多余85%，你还回收他干什么？这个时候要把85%的对象都拷贝到别的Region，这个成本是很高的。


> 回收失败时的Full GC

如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region里去.

此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 次失败。

一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢极慢的。



















# 98、Java线程和操作系统线程的关系

[深入分析JVM中线程的创建和运行原理](https://mp.weixin.qq.com/s?__biz=MzIwMzY1OTU1NQ==&mid=2247485264&idx=1&sn=e26328e751063eeaca741d02fdd7a0f8&chksm=96cd471ca1bace0af19553394810e6cde0aa69f32f53e986a0cbe7888f6066ae7b07914550c7&mpshare=1&scene=24&srcid=0104abix9tU0p6oxRhSG0xVt#rd)

问题：Java里的线程和操作系统的线程是什么关系？它们是如何对应的？






















