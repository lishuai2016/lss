
<!-- TOC -->

- [1、类的初始化顺序](#1类的初始化顺序)
    - [1、原理](#1原理)
    - [2、类的准备阶段](#2类的准备阶段)
    - [3、类的初始化阶段](#3类的初始化阶段)
- [参考](#参考)

<!-- /TOC -->

# 1、类的初始化顺序

## 1、原理

- 1、加载类信息。在实例化对象之前，类的装载器会找到需要加载的类class文件，进行类的加载（有父类的会先加载父类），一旦加载到最根上的基类，就会对基类的静态变量和静态初始化块进行初始化；

- 2、当所有类信息加载完毕就会执行main（）主方法，然后执行new class（），对类进行实例化，首先对变量和、初始化块以及类的构造函数进行初始化（有父类的首先会对父类进行初始化，多个父类递归的方式）


```java
com.ls.classload.StaticTest

public class StaticTest {
   public static void main(String[] args){
       staticFunction();
   }

   static StaticTest st = new StaticTest();
   //静态代码块
   static{
       System.out.println("1");
   }
   //实例代码块
   {
       System.out.println("2");
   }
   //构造函数
   StaticTest() {
       System.out.println("3");
       System.out.println("a="+a+",b="+b);
   }

   public static void staticFunction(){
       System.out.println("4");
   }

   int a=110;
   static int b =112;
}
```
问题：请问这段程序的输出是什么？一般对于这类问题，小伙伴们脑海中肯定浮现出这样的知识点:Java中赋值一般顺序

```
父类的静态变量赋值
自身的静态变量赋值
父类成员变量赋值和父类块赋值
父类构造函数赋值
自身成员变量赋值和自身块赋值
自身构造函数赋值
```

按照这个理论输出是什么呢？答案输出:1 4，这样正确嚒？肯定不正确啦，这里不是说上面的规则不正确，而是说不能简单的套用这个规则。 正确的答案是：
2
3
a=110,b=0
1
4

有没有答对呢？这里主要的点之一：`实例初始化不一定要在类初始化结束之后才开始初始化` 

类的生命周期是：加载->验证->准备->解析->初始化->使用->卸载，只有在准备阶段和初始化阶段才会涉及类变量的初始化和赋值，因此只针对这两个阶段进行分析；

## 2、类的准备阶段

需要做是为[类变量分配内存并设置默认值]，因此类变量st为null、b为0；

（需要注意的是如果类变量是final，编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量设置为指定的值，如果这里这么定义：static final int b=112,那么在准备阶段b的值就是112，而不再是0了。）

## 3、类的初始化阶段

需要做的是执行类构造器（`类构造器`是编译器收集所有静态语句块和类变量的赋值语句按语句在源码中的顺序合并生成类构造器，对象的构造方法是()，类的构造方法是()，可以在堆栈信息中看到），因此先执行第一条静态变量的赋值语句即st = new StaticTest ()，此时会进行对象的初始化，`对象的初始化是先初始化成员变量再执行构造方法`，因此打印2->设置a为110->执行构造方法(打印3,此时a已经赋值为110，但是b只是设置了默认值0，并未完成赋值动作)，等对象的初始化完成后继续执行之前的类构造器的语句，接下来就不详细说了，按照语句在源码中的顺序执行即可。


这里面还牵涉到一个冷知识，就是在`嵌套初始化`时有一个特别的逻辑。特别是内嵌的这个变量恰好是个静态成员，而且是本类的实例。 这会导致一个有趣的现象：“`实例初始化竟然出现在静态初始化之前`”。 其实并没有提前，你要知道java记录初始化与否的时机。看一个简化的代码，把关键问题解释清楚：

```java
public class Test {
   public static void main(String[] args) {
       func();
   }
   static Test st = new Test();
   static void func(){}
}
```

根据上面的代码，有以下步骤：

- 1、首先在执行此段代码时，首先由main方法的调用触发静态初始化。
- 2、在初始化Test 类的静态部分时，遇到st这个成员。

但凑巧这个变量引用的是本类的实例。那么问题来了，此时静态初始化过程还没完成就要初始化实例部分了。是这样么？从人的角度是的。但从java的角度，一旦开始初始化静态部分，无论是否完成，后续都不会再重新触发静态初始化流程了。因此在实例化st变量时，实际上是把实例初始化嵌入到了静态初始化流程中，并且嵌入到了静态初始化的起始位置。这就导致了实例初始化完全至于静态初始化之前。这也是导致a有值b没值的原因。




# 参考

- [类初始化流程](https://blog.csdn.net/l1394049664/article/details/81235456)

- [Java类初始化顺序](https://segmentfault.com/a/1190000004527951)

- [分享一道大多数人都会做错的JVM题](https://mp.weixin.qq.com/s?__biz=MzU0MzQ5MDA0Mw==&mid=2247484492&idx=1&sn=8a46169ddf5781186a163c5387657f58&chksm=fb0beed8cc7c67ce65c2f0efe1ed98d185097c58d72dae437f053e3c01dfbc0ba4f57e7172a4&mpshare=1&scene=24&srcid=1227DI8IJiSNnWKdRnehC5JA#rd)

- [解析 Java 类和对象的初始化过程](https://www.ibm.com/developerworks/cn/java/j-lo-clobj-init/index.html)