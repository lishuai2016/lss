

<!-- TOC -->

- [第 1 章　为什么要关心Java 8](#第-1-章　为什么要关心java-8)
- [第 2 章　通过行为参数化传递代码](#第-2-章　通过行为参数化传递代码)
- [第 3 章　Lambda表达式](#第-3-章　lambda表达式)
- [第 4 章　引入流](#第-4-章　引入流)
- [第 5 章　使用流](#第-5-章　使用流)
- [第 6 章　用流收集数据](#第-6-章　用流收集数据)
- [第 7 章　并行数据处理与性能](#第-7-章　并行数据处理与性能)
- [第 8 章　重构、测试和调试](#第-8-章　重构测试和调试)
- [第 9 章　默认方法](#第-9-章　默认方法)
- [第 10 章　用Optional取代null](#第-10-章　用optional取代null)
- [第 11 章　CompletableFuture：组合式异步编程](#第-11-章　completablefuture组合式异步编程)
- [第 12 章　新的日期和时间API](#第-12-章　新的日期和时间api)
- [第 13 章　函数式的思考](#第-13-章　函数式的思考)
- [第 14 章　函数式编程的技巧](#第-14-章　函数式编程的技巧)
- [第 15 章　面向对象和函数式编程的混合：Java 8和Scala的比较](#第-15-章　面向对象和函数式编程的混合java-8和scala的比较)
- [第 16 章　结论以及Java的未来](#第-16-章　结论以及java的未来)

<!-- /TOC -->


> java8特点

- Stream API（隐藏内部实现，提供并发API降低并发变成的成本和安全项）
- 向方法传递代码的技巧（之前只有参数对象可以做方法入参，现在方法也可以作为入参）
- 接口中的默认方法（给接口添加方法时不需要继承类实现，扩展已有接口的功能）







> 第一部分　基础知识

# 第 1 章　为什么要关心Java 8

> 总结

- 现有的Java编程实践并不能很好地利用多核处理器。
- 函数是一等值；记得方法如何作为函数式值来传递，还有Lambda是怎样写的。
- Java 8中Streams的概念使得Collections的许多方面得以推广，让代码更为易读，并允许并行处理流元素。
- 你可以在接口中使用默认方法，在实现类没有实现方法时提供方法内容。
- 其他来自函数式编程的有趣思想，包括处理null`Optional<T>`和使用模式匹配

- Predicate<T> 




# 第 2 章　通过行为参数化传递代码 
# 第 3 章　Lambda表达式 
> 第二部分　函数式数据处理 
# 第 4 章　引入流 
# 第 5 章　使用流 
# 第 6 章　用流收集数据 
# 第 7 章　并行数据处理与性能 
> 第三部分　高效Java 8编程 
# 第 8 章　重构、测试和调试 
# 第 9 章　默认方法 
# 第 10 章　用Optional取代null 
# 第 11 章　CompletableFuture：组合式异步编程 
# 第 12 章　新的日期和时间API 
> 第四部分　超越Java 8 
# 第 13 章　函数式的思考 
# 第 14 章　函数式编程的技巧 
# 第 15 章　面向对象和函数式编程的混合：Java 8和Scala的比较 
# 第 16 章　结论以及Java的未来 



附录 A　其他语言特性的更新 

附录 B　类库的更新  阅读 
附录 C　如何以并发方式在同一个流上执行多种操作 
附录 D　Lambda表达式和JVM字节码 